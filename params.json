{"name":"Flox","tagline":"yet another Flux-like for React","body":"# Synopsis\r\n\r\n**Flox** is a framework/architecture for [React](http://facebook.github.io/react) loosely based on the [Flux architecture](http://facebook.github.io/flux) and inspired by [Reflux](https://www.npmjs.org/package/reflux) and [Fluxxor](http://fluxxor.com).\r\n\r\nFlox is unrelated to [flocks.js](https://github.com/StoneCypher/flocks.js), which is another alternative architecture for React.\r\n\r\n[![Gitter](https://badges.gitter.im/Join Chat.svg)](https://gitter.im/foss-haas/flox)\r\n\r\n[![license - MIT](https://img.shields.io/npm/l/flox.svg)](https://foss-haas.mit-license.org) [![Dependencies](https://img.shields.io/david/foss-haas/flox.svg)](https://david-dm.org/foss-haas/flox)\r\n\r\n[![NPM status](https://nodei.co/npm/flox.png?compact=true)](https://npmjs.org/package/flox)\r\n\r\n[![Build Status](https://img.shields.io/travis/foss-haas/flox.svg)](https://travis-ci.org/foss-haas/flox) [![Coverage Status](https://img.shields.io/coveralls/foss-haas/flox.svg)](https://coveralls.io/r/foss-haas/flox?branch=master)\r\n\r\n# Install\r\n\r\n## With NPM\r\n\r\n```sh\r\nnpm install flox\r\n```\r\n\r\n## From source\r\n\r\n```sh\r\ngit clone https://github.com/foss-haas/flox.git\r\ncd flox\r\nnpm install\r\nnpm run dist\r\n```\r\n\r\n# Usage\r\n\r\n## Obligatory ASCII diagram\r\n\r\n```\r\n  ╔═════════╗       ╔════════╗      ╔═════════════════╗\r\n  ║ Actions ╟──────>║ Stores ╟─────>║ View Components ║\r\n  ╚════╤════╝       ╚════════╝      ╚══════╤═══╤══════╝\r\n    ^  │  ^                                │   │\r\n    │  │  └────────────────────────────────┘   │\r\n    │  v                                       v\r\n  ╔═╧════════╗     ┌────────────┐   ╔═════════════════╗\r\n  ║ Services ╟────>│ Server API │   ║ Pure Components ║\r\n  ╚══════════╝     └────────────┘   ╚═════════════════╝\r\n```\r\n\r\n## Definitions\r\n\r\n**Actions** are listenable functions that emit whatever data is passed to them. They provide the core building block of all interactions between *View Components* or *Services* and the *Stores*.\r\n\r\n**Stores** are listenable functions that contain the application state and emit their contents whenever they are written to. In Flox, those contents are generally immutable, so modifying them requires updating the store that contains them.\r\n\r\n**View Components** are components that listen to *Stores* and/or invoke *Actions*. According to the philosophy of React these should usually be the outer most components in an application. They pass the (immutable) data from *Stores* as props to the underlying **Pure Components**, the regular self-contained React components. They may also invoke *Actions* as the result of user interaction with the components.\r\n\r\n**Services** listen to *Actions* and connect them with each other. They are the only part of the application that communicates directly with the *Server API*. In practice, a service may simply be a function that is registered with an action as a listener and invokes a different action.\r\n\r\nThe **Server API** is the code that directly communicates with the remote server or persistence layer of the application. Its implementation should be entirely orthogonal to the rest of the application. For example, a thin wrapper around `XMLHttpRequest` that takes arguments and a callback or returns a promise.\r\n\r\n## Example: Login view\r\n\r\nWe're going to assume the Server API is an object that provides a single method with the following signature that returns a promise which resolves to the user data or is rejected with a descriptive error message that can be presented to the user:\r\n\r\n`api.login(username:String, password:String):Promise`\r\n\r\nThe application needs at least the following actions:\r\n\r\n* `attemptLogin` for when a user attempts a login.\r\n* `loginComplete` for when the server has acknowledged a login.\r\n* `loginFailed` for when the server has denied a login attempt.\r\n\r\nThey don't need to do anything special, so we can just use the bulk creation method to create all three of them:\r\n\r\n```js\r\nvar actions = Flox.createActions([\r\n  'attemptLogin',\r\n  'loginComplete',\r\n  'loginFailed'\r\n]);\r\n```\r\n\r\nThe application also needs a store for the user data. We're going to assume that the user data will always be a simple mapping of keys and values (i.e. a plain object) that requires no special processing:\r\n\r\n```js\r\nvar immutable = require('immutable');\r\nvar userStore = Flox.createStore(immutable.Map());\r\nactions.loginComplete.listen(function (userData) {\r\n  userStore(userData);\r\n});\r\n```\r\n\r\nThere is only one service, which needs to react to the `attemptLogin` action and then invokes either `loginComplete` or `loginFailed` depending on the result of `api.login`:\r\n\r\n```js\r\nactions.attemptLogin.listen(function (credentials) {\r\n  api.login(credentials.username, credentials.password)\r\n  .then(\r\n    function (userData) { // promise resolved\r\n      actions.loginComplete(userData);\r\n    },\r\n    function (errorMessage) { // promise rejected\r\n      actions.loginFailed(errorMessage);\r\n    }\r\n  );\r\n  // or simply: .then(actions.loginComplete, actions.loginFailed);\r\n});\r\n```\r\n\r\nIf that service looks simple that's because it is. The server API does the heavy lifting of communicating with the server, so we're only left with a little bit of glue.\r\n\r\nFinally, the controller view itself:\r\n\r\n```js\r\nvar Login = React.createComponent({\r\n  mixins: [\r\n    Flox.connect(userStore, 'user'),\r\n    Flox.listenTo(actions.loginFailed, 'handleLoginFailed')\r\n  ],\r\n  getInitialState() {\r\n    return {username: '', password: '', error: null};\r\n  },\r\n  handleLoginFailed(errorMessage) {\r\n    this.setState({error: errorMessage});\r\n  },\r\n  handleFormSubmit(evt) {\r\n    evt.preventDefault();\r\n    actions.attemptLogin(this.state.username, this.state.password);\r\n  },\r\n  handleUsernameChange(evt) {\r\n    this.setState({username: evt.target.value});\r\n  },\r\n  handlePasswordChange(evt) {\r\n    this.setState({password: evt.target.value});\r\n  },\r\n  render() {\r\n    if (this.state.user.get('username')) {\r\n      return <div>Already logged in.</div>;\r\n    }\r\n    return (\r\n      <form onSubmit={this.handleFormSubmit}>\r\n        {this.state.error}\r\n        <label>\r\n          Username:\r\n          <input type=\"text\" value={this.state.username}\r\n            onChange={this.handleUsernameChange}/>\r\n        </label>\r\n        <label>\r\n          Password:\r\n          <input type=\"password\" value={this.state.password}\r\n            onChange={this.handlePasswordChange}/>\r\n        </label>\r\n        <button>Log in</button>\r\n      </form>\r\n    );\r\n  }\r\n});\r\n```\r\n\r\n### Pragmatism beats purity\r\n\r\nAs you may have noticed, we're listening to `loginFailed` directly in our controller view. If we followed the initial definitions religiously we would have had to introduce a `loginErrorStore` to connect the controller view with the action.\r\n\r\nYou may find it useful to create additional abstractions like the `loginErrorStore` in your real-world applications, but unless your login logic is going to become relatively complex, the benefits of the additional degrees of conceptual purity likely would not outweigh their costs.\r\n\r\nFlox tries to be as unopinionated as it can while remaining useful. The architecture recommended by this document is intended as a guideline, not a law. You may deviate from it as much as you like.\r\n\r\n## But what about waitFor?\r\n\r\nFlux has `waitFor`, Flox does not. Because Flux's dispatcher is entirely replaced by Flox's services and you're encouraged to create as many different actions as your application needs, you'll rarely run into situations where stores actually depend on each other in a way that can't be solved with a few event listeners.\r\n\r\nIf you run into a real-world scenario you can't solve with additional actions or services, feel free to [report an issue on GitHub](https://github.com/foss-haas/flox/issues) or [discuss it on Gitter](https://gitter.im/foss-haas/flox). Otherwise, just stick to the Flox mantra: *If in doubt, use more duct tape!*\r\n\r\n# API\r\n\r\n## createAction([spec]):action\r\n\r\nCreates an action optionally extended with the given `spec`.\r\n\r\nReturns a function that will pass its argument to all of its listeners.\r\n\r\nIf `spec` has a method `beforeEmit`, values will be pre-processed by passing them to that method first and using its return value.\r\n\r\nIf `spec` has a method `shouldEmit`, the action will only call its listeners if the result of passing the (pre-processed) value to that method is truthy.\r\n\r\n### action.listen(listener, [context]):Function\r\n\r\nRegisters a listener with the action. The listener will be invoked whenever the action emits a value.\r\n\r\nThe listener will be bound to the given `context`.\r\n\r\nReturns a function that will remove the listener from the action when called.\r\n\r\n### action.unlisten(listener, [context])\r\n\r\nRemoves a listener from the action. This has the same effect as calling the function returned by `action.listen`. If the listener was registered with a context, the same context must be used.\r\n\r\n## createActions(specs):Object\r\n\r\nCreates actions for the given `specs`. Convenience wrapper around `createAction` for bulk creation of actions.\r\n\r\nIf `specs` is an array of strings, returns an object mapping the strings to actions.\r\n\r\nIf `specs` is an object, returns an object mapping the object's keys to the result of calling `createAction` with the object's values.\r\n\r\n## createStore(emptyValue, [prepare]):store\r\n\r\nCreates a store for immutable data initialized with the given `emptyValue`.\r\n\r\nReturns a function with the following behaviour:\r\n* when called without arguments, returns an immutable cursor for the store's content.\r\n* when called with `null`, resets the store's value to `emptyValue`.\r\n* when called with any other defined value, sets the store's value to the result of passing that value to `immutable.fromJS`.\r\n\r\nIf `prepare` is a function, values other than `null` and `undefined` passed to the store will be preprocessed using that function.\r\n\r\nWhenever the store's value changes, an immutable cursor for the store's content will be passed to its listeners.\r\n\r\n### store.listen(listener, [context]):Function\r\n\r\nRegisters a change listener with the store. The listener will be invoked with an immutable cursor for the store's new content whenever it is written to.\r\n\r\nThe listener will be bound to the given `context`.\r\n\r\nReturns a function that will remove the listener from the store when called.\r\n\r\n### store.unlisten(listener, [context])\r\n\r\nRemoves a change listener from the store. This has the same effect as calling the function returned by `store.listen`. If the listener was registered with a context, the same context must be used.\r\n\r\n### store.isEmpty():Boolean\r\n\r\nReturns `true` if the store's current value is equivalent to its `emptyValue` or `false` otherwise.\r\n\r\n### store.isEmpty.listen(listener, [context]):Function\r\n\r\nLike `store.listen`, but receives a boolean value indicating whether the store is empty (i.e. the result of calling `store.isEmpty()`) instead of a cursor to the store's new content.\r\n\r\n### store.isEmpty.unlisten(listener, [context])\r\n\r\nRemoves a change listener from `store.isEmpty`. This has the same effect as calling the function returned by `store.isEmpty.listen`. If the listener was registered with a context, the same context must be used.\r\n\r\n## createRawStore(emptyValue, [prepare]):rawStore\r\n\r\nCreates a store initialized with the given `emptyValue`.\r\n\r\nBehaves like `createStore` with the following differences:\r\n* values are not passed to `immutable.fromJS`.\r\n* always returns the raw (prepared) value where a regular store would return an immutable cursor.\r\n\r\nRaw stores can be useful if you want to store data that can't be meaningfully represented by `immutable`'s data structures.\r\n\r\n## listenTo(listenable, listener):Mixin\r\n\r\nCreates a React mixin that registers the given listener function with the given `listenable` store or action (or anything that has methods `listen(fn, ctx)` and `unlisten(fn, ctx)`). The listener will be invoked with its context set to the React component.\r\n\r\nIf `listener` is a string, the component's method with the given name will be used.\r\n\r\nRegisters the listener on `componentDidMount` and unregisters it on `componentWillUnmount`.\r\n\r\n## connect(store, name):Mixin\r\n\r\nCreates a React mixin that updates the component's state by setting `name` to the store's value whenever the store's value changes.\r\n\r\nAutomatically adds the store's current value to the component's initial state.\r\n\r\nRegisters the listener on `componentDidMount` and unregisters it on `componentWillUnmount`.\r\n\r\n## connectProp(propName, name):Mixin\r\n\r\nCreates a React mixin that updates the component's state by setting `name` to the value of the store in the prop `propName` whenever the store's value changes.\r\n\r\nAutomatically adds the store's current value to the component's initial state and reacts to prop changes.\r\n\r\nRegisters the listener on `componentDidMount` and unregisters it on `componentWillUnmount`.\r\n\r\n# License\r\n\r\nThe MIT/Expat license. For more information, see http://foss-haas.mit-license.org/ or the accompanying [LICENSE](https://github.com/foss-haas/flox/blob/master/LICENSE) file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}